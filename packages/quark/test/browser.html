<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quark Browser Tests</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    h1 {
      color: #60a5fa;
      margin-bottom: 10px;
      font-size: 28px;
    }

    .subtitle {
      color: #9ca3af;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .summary {
      background: #2a2a2a;
      border-left: 4px solid #60a5fa;
      padding: 15px 20px;
      margin-bottom: 20px;
      border-radius: 4px;
    }

    .summary.success {
      border-color: #10b981;
      background: #1a2e25;
    }

    .summary.failure {
      border-color: #ef4444;
      background: #2e1a1a;
    }

    .test {
      background: #2a2a2a;
      padding: 12px 16px;
      margin-bottom: 8px;
      border-radius: 4px;
      border-left: 3px solid transparent;
    }

    .test.pass {
      border-color: #10b981;
    }

    .test.fail {
      border-color: #ef4444;
      background: #2e1a1a;
    }

    .test-name {
      font-weight: 500;
      margin-bottom: 4px;
    }

    .test.pass .test-name::before {
      content: '‚úÖ ';
    }

    .test.fail .test-name::before {
      content: '‚ùå ';
    }

    .test-assertion {
      font-size: 13px;
      color: #9ca3af;
      padding-left: 24px;
    }

    .test.pass .test-assertion::before {
      content: '  ‚úì ';
      color: #10b981;
    }

    .test.fail .test-assertion::before {
      content: '  ‚úó ';
      color: #ef4444;
    }

    .error {
      color: #f87171;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 8px 12px;
      background: #1a1a1a;
      border-radius: 3px;
      margin-top: 8px;
      white-space: pre-wrap;
    }

    .perf-note {
      color: #60a5fa;
      font-size: 13px;
      padding-left: 48px;
      margin-top: 4px;
    }

    .stats {
      display: flex;
      gap: 20px;
      margin-top: 15px;
    }

    .stat {
      font-size: 18px;
      font-weight: 600;
    }

    .stat.passed {
      color: #10b981;
    }

    .stat.failed {
      color: #ef4444;
    }

    .stat.total {
      color: #60a5fa;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #9ca3af;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üß™ Quark Browser Tests</h1>
    <div class="subtitle">High-Performance Reactive Container - Browser Runtime Verification</div>

    <div id="output">
      <div class="loading">Running tests...</div>
    </div>
  </div>

  <script src="../dist/quark.browser.js"></script>
  <script>
    const { Qu, Qv } = Quark;
    const createQu = Qu;

    let testsPassed = 0;
    let testsFailed = 0;
    let output = '';
    let currentTest = '';
    let currentAssertions = [];

    function assert(condition, message) {
      if (!condition) {
        testsFailed++;
        currentAssertions.push({ pass: false, message });
        throw new Error(message);
      } else {
        testsPassed++;
        currentAssertions.push({ pass: true, message });
      }
    }

    function test(name, fn) {
      currentTest = name;
      currentAssertions = [];

      try {
        fn();

        output += `<div class="test pass">
          <div class="test-name">${name}</div>
          ${currentAssertions.map(a => `<div class="test-assertion">${a.message}</div>`).join('')}
        </div>`;
      } catch (error) {
        output += `<div class="test fail">
          <div class="test-name">${name}</div>
          ${currentAssertions.map(a =>
            `<div class="test-assertion ${a.pass ? '' : 'fail'}">${a.message}</div>`
          ).join('')}
          <div class="error">${error.message}</div>
        </div>`;
      }
    }

    function render() {
      const isSuccess = testsFailed === 0;

      document.getElementById('output').innerHTML = `
        <div class="summary ${isSuccess ? 'success' : 'failure'}">
          <div style="font-size: 20px; margin-bottom: 10px;">
            ${isSuccess ? 'üéâ All tests passed!' : 'üí• Some tests failed!'}
          </div>
          <div class="stats">
            <div class="stat passed">‚úÖ Passed: ${testsPassed}</div>
            <div class="stat failed">‚ùå Failed: ${testsFailed}</div>
            <div class="stat total">üìà Total: ${testsPassed + testsFailed}</div>
          </div>
        </div>
        ${output}
      `;
    }

    // Run all tests
    try {
      // ============================================================================
      // TESTS
      // ============================================================================

      test('Browser: Basic creation', () => {
        const q = createQu();
        assert(q.value === undefined, 'Empty quark should have undefined value');

        const q2 = createQu({ value: 42 });
        assert(q2.value === 42, 'Quark should have initial value 42');
      });

      test('Browser: Qv alias', () => {
        const q = Qv(100);
        assert(q.value === 100, 'Qv should create quark with value');
      });

      test('Browser: Get/Set', () => {
        const counter = Qv(0);
        assert(counter.value === 0, 'Initial value should be 0');

        counter(10);
        assert(counter.value === 10, 'Value should be updated to 10');

        counter(20);
        assert(counter.value === 20, 'Value should be updated to 20');
      });

      test('Browser: Listeners', () => {
        const q = Qv(0);
        let callCount = 0;
        let lastValue = null;

        q.up((value) => {
          callCount++;
          lastValue = value;
        });

        assert(callCount === 1, 'Listener called immediately with existing value');
        assert(lastValue === 0, 'Listener should receive initial value 0');

        q(5);
        assert(callCount === 2, 'Listener should be called on update');
        assert(lastValue === 5, 'Listener should receive new value 5');
      });

      test('Browser: Multiple listeners', () => {
        const q = Qv(0);
        let count1 = 0;
        let count2 = 0;

        q.up(() => count1++);
        q.up(() => count2++);

        assert(count1 === 1, 'First listener called');
        assert(count2 === 1, 'Second listener called');

        q(10);
        assert(count1 === 2, 'First listener called on update');
        assert(count2 === 2, 'Second listener called on update');
      });

      test('Browser: down() removes listener', () => {
        const q = Qv(0);
        let count = 0;
        const listener = () => count++;

        q.up(listener);
        q(5);

        q.down(listener);
        q(10);

        assert(count === 2, 'Listener should not be called after down()');
      });

      test('Browser: dedup mode', () => {
        const q = Qv(10, { dedup: true });
        let callCount = 0;

        q.up(() => callCount++);
        assert(callCount === 1, 'Listener called immediately');

        q(10);
        assert(callCount === 1, 'Dedup should prevent duplicate notifications');

        q(20);
        assert(callCount === 2, 'Different value should trigger');
      });

      test('Browser: stateless mode', () => {
        const q = createQu({ stateless: true });
        let received = [];

        q.up((value) => received.push(value));

        q('event1');
        q('event2');

        assert(received.length === 2, 'Stateless should still notify');
        assert(q.value === undefined, 'Stateless should not store value');
      });

      test('Browser: pipe transform', () => {
        const q = Qv(0);
        q.pipe((value) => {
          if (value < 0) return undefined;
          return Math.round(value);
        });

        q(5.7);
        assert(q.value === 6, 'Pipe should round value');

        q(-10);
        assert(q.value === 6, 'Pipe should reject negative value');
      });

      test('Browser: Events - local', () => {
        const q = createQu();
        let received = null;

        q.on('test', (data) => {
          received = data;
        });

        q.emit('test', { foo: 'bar' });

        assert(received !== null, 'Event should be received');
        assert(received.data.foo === 'bar', 'Event data should be passed');
      });

      test('Browser: Events - realm', () => {
        const q1 = createQu({ realm: 'r1', id: 'q1' });
        const q2 = createQu({ realm: 'r2' });

        let received = null;

        q2.on('r1:custom', (data) => {
          received = data;
        });

        q1.emit('custom', { msg: 'hello' });

        assert(received !== null, 'Cross-realm event should be received');
        assert(received.data.msg === 'hello', 'Cross-realm data should be passed');
      });

      test('Browser: QUARK_AWAKE event', () => {
        const counter = createQu({ realm: 'counters', id: 'test' });
        const logger = createQu({ realm: 'logs' });

        let awakeCount = 0;
        let awakeData = null;

        logger.on('counters:QUARK_AWAKE', (data) => {
          awakeCount++;
          awakeData = data;
        });

        counter(1);
        assert(awakeCount === 1, 'QUARK_AWAKE should emit once');
        assert(awakeData.id === 'test', 'QUARK_AWAKE should have id');

        counter(2);
        assert(awakeCount === 1, 'QUARK_AWAKE should only emit once');
      });

      test('Browser: Performance - rapid updates', () => {
        const q = Qv(0);
        let callCount = 0;

        q.up(() => callCount++);

        const start = performance.now();
        for (let i = 0; i < 10000; i++) {
          q(i);
        }
        const time = Math.round(performance.now() - start);

        assert(callCount === 10001, 'All updates should trigger listener');
        assert(time < 200, `Performance should be good: ${time}ms for 10k updates`);

        currentAssertions.push({
          pass: true,
          message: `‚ö° Performance: ${time}ms for 10,000 updates`,
          isPerfNote: true
        });
      });

      test('Browser: silent() blocks notifications', () => {
        const q = Qv(0);
        let count = 0;

        q.up(() => count++);
        assert(count === 1, 'Immediate call');

        q.silent(() => {
          q(10);
          q(20);
          q(30);
        });

        assert(count === 1, 'silent() should block notifications');
        assert(q.value === 30, 'Value should still be updated');

        q(40);
        assert(count === 2, 'Notifications should work after silent()');
      });

      test('Browser: decay() cleanup', () => {
        const q = Qv(10);
        q.up(() => {});
        q.on('test', () => {});

        q.decay();

        assert(q.value === undefined, 'decay() should clear value');
        assert(!q.hasListeners, 'decay() should clear listeners');
      });

      test('Browser: DOM Integration - reactive counter', () => {
        const counter = Qv(0);
        let displayValue = null;

        counter.up((value) => {
          displayValue = value;
        });

        assert(displayValue === 0, 'Initial display should be 0');

        counter(counter.value + 1);
        assert(displayValue === 1, 'Display should update to 1');

        counter(counter.value + 1);
        assert(displayValue === 2, 'Display should update to 2');
      });

      test('Browser: typeof checks', () => {
        const q = Qv(42);

        assert(typeof q === 'function', 'Quark should be a function');
        assert(typeof q.value === 'number', 'Value should be a number');
        assert(typeof q.up === 'function', 'up should be a function');
        assert(typeof q.down === 'function', 'down should be a function');
        assert(typeof q.on === 'function', 'on should be a function');
        assert(typeof q.emit === 'function', 'emit should be a function');
      });

      test('Browser: Memory - multiple quarks', () => {
        const quarks = [];
        for (let i = 0; i < 1000; i++) {
          quarks.push(Qv(i));
        }

        assert(quarks.length === 1000, 'Should create 1000 quarks');
        assert(quarks[0].value === 0, 'First quark should have value 0');
        assert(quarks[999].value === 999, 'Last quark should have value 999');
      });

    } catch (error) {
      console.error('Test error:', error);
    }

    render();
  </script>
</body>
</html>
