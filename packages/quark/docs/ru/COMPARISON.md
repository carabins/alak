# Сравнение: Quark vs Signals vs Observables

Этот документ содержит техническое сравнение **@alaq/quark** с современными **Сигналами** (Signals: SolidJS, Preact, Vue) и **Observables** (RxJS).

## Краткий обзор

| Характеристика | @alaq/quark | Signals (Solid/Preact) | Observables (RxJS) |
| :--- | :--- | :--- | :--- |
| **Главная цель** | **Производительность и Память** | DX и Авто-трекинг | Сложная композиция событий |
| **Поток данных** | Атомарный + Шина Событий | Граф Зависимостей | Push-потоки (Streams) |
| **Модель Памяти** | **Мономорфный Класс** | Связные списки / Узлы | Цепочки замыканий/объектов |
| **Стоимость обновления** | Около нуля (Прямой вызов) | Обход графа | Выполнение цепочки операторов |
| **Отслеживание зависимостей** | Ручное (`.up`) / Явное | **Автоматическое** (Магия) | Явное (`.pipe`, `.subscribe`) |
| **Межмодульная связь** | **Нативная (Realms)** | Context / Props | Subjects |

---

## 1. Против Observables (RxJS)

RxJS — индустриальный стандарт для работы со сложными асинхронными потоками. Однако для управления состоянием приложения он часто избыточен и тяжеловесен.

### Разметка Памяти (Memory Layout)
*   **RxJS:** Создание потока часто вовлекает создание множества областей видимости замыканий и объектов (Observable -> Operator -> Subscriber). Каждая подписка создает новый объект `Subscription`.
*   **Quark:** Кварк — это единый объект с предсказуемым "Скрытым Классом" (Hidden Class) в V8. Он не аллоцирует замыкания на каждый экземпляр. Слушатели хранятся в простом массиве.

### Производительность
*   **RxJS:** Обновление значения запускает цепочку вызовов функций через пайплайн операторов.
*   **Quark:** Обновление значения — это прямая итерация массива: `for (let i=0; i<len; i++) listeners[i](val)`. Это ближе к нативной инструкции CPU, чем к абстракции фреймворка.

### Вывод
Используйте **RxJS**, когда нужно обрабатывать сложные временные события (debounce, distinctUntilChanged, mergeMap).
Используйте **Quark**, когда нужно быстрое, простое хранилище состояния с прямой реактивностью.

---

## 2. Против Signals (SolidJS, Preact, Vue)

Сигналы — текущий тренд в UI-фреймворках. Они превосходны для точечных обновлений DOM.

### Отслеживание зависимостей (Dependency Tracking)
*   **Сигналы:** Поддерживают двусвязный список зависимостей. При чтении сигнала он проверяет глобальный контекст, чтобы узнать, кто его читает, и добавляет их в граф. Это имеет вычислительную стоимость (бухгалтерия) при каждом чтении/записи для поддержания актуальности графа.
*   **Quark:** Он "глупый". Он не отслеживает, кто его читает. Он только уведомляет явных слушателей. Это убирает накладные расходы на обслуживание графа. (Примечание: Слой `@alaq/nucl` добавляет трекинг поверх Quark при необходимости, но сам Quark остается чистым).

### Проблема "Глитчей" (Glitch Problem)
*   **Сигналы:** Тратят такты CPU на обеспечение консистентности "Проблемы Ромба" (Diamond Problem), избегая двойных обновлений в графах A->B->D, A->C->D.
*   **Quark:** Следует "Push" модели. Если вы обновляете A, то B и C обновятся немедленно. Это проще и быстрее, но требует от разработчика (или оркестратора `Atom`) контроля архитектуры.

### Вывод
Используйте **Сигналы** для рендеринга UI, где критичны автоматические точечные обновления.
Используйте **Quark** для слоя бизнес-логики, игрового состояния или высокочастотных данных (координаты мыши, веб-сокеты), где оверхед графа нежелателен.

---

## 3. Отличие "Quantum Bus"

Ни Сигналы, ни базовые Observables не предоставляют встроенного архитектурного паттерна для межмодульной коммуникации.

*   **Остальные:** Обычно вам приходится экспортировать глобальную переменную или использовать React Context / Dependency Injection для шаринга состояния.
*   **Quark:** Поставляется с **Realms (Мирами)**. Кварк может транслировать свои изменения в именованный канал (`realm: 'auth'`). Это позволяет полностью развязать модули: один модуль реагирует на изменения состояния другого, даже не импортируя сам объект состояния.

## Резюме

**Quark — это не замена RxJS или Signals во всех случаях.**

Это **низкоуровневый примитив**, созданный для:
1.  **Максимальной производительности:** Когда каждая микросекунда на счету (Игры, HFT, тяжелая визуализация).
2.  **Ограничений памяти:** Создание 100,000 кварков дешевле, чем 100,000 Observables.
3.  **Архитектуры:** Когда нужна событийно-ориентированная архитектура через Realms.
