# Fusion (Синтез и Computed)

**Fusion** — это механизм для создания зависимых (вычисляемых) значений на основе одного или нескольких нуклонов.

## Использование (Builder)

Функция `fusion(...sources)` возвращает объект-строитель, который позволяет выбрать стратегию вычисления.

```typescript
import { Nv, fusion } from '@alaq/nucl';

const price = Nv(100);
const quantity = Nv(2);

// Создание вычисляемого значения
const total = fusion(price, quantity).alive((p, q) => p * q);

console.log(total.value); // 200
```

## Стратегии вычисления

### `.alive(fn)`
Самая распространенная стратегия. Функция вычисления запускается только если **все** источники имеют "валидное" значение (не `null` и не `undefined`).
Идеально подходит для цепочек данных, где отсутствие одного звена делает расчет бессмысленным.

### `.any(fn)`
Функция вычисления запускается при **любом** изменении любого из источников, даже если их значения стали `null` или `undefined`.

---

## Важные особенности

1.  **Тип результата**: Fusion возвращает полноценный Nucl. Вы можете подписываться на него через `.up()` или использовать его как источник для другого Fusion.
2.  **Управление жизненным циклом**: Если один из исходных нуклонов вызывается через `.decay()`, синтезированный нуклон также переходит в состояние `undefined` и прекращает обновления.
3.  **Немедленное вычисление**: При создании Fusion сразу вычисляет начальное значение.

## Эффекты (Side Effects)

Если вам не нужно создавать новое значение, а нужно просто выполнить действие при изменении группы нуклонов, используйте вспомогательные функции из `@alaq/nucl/fusion/effects`:

- **`aliveFusion(sources, fn)`** — Выполняет `fn`, когда все источники валидны.
- **`anyFusion(sources, fn)`** — Выполняет `fn` при любом изменении.

Обе функции возвращают `cleanup` функцию для отписки.

```typescript
import { aliveFusion } from '@alaq/nucl/fusion/effects';

const stop = aliveFusion([user, token], (u, t) => {
  console.log(`Пользователь ${u} авторизован с токеном ${t}`);
});

// Для отписки:
stop();
```
