# @alaq/nucleus Справочник API

Полная документация API реактивного примитива Nucleus.

---

## Содержание

- [Основные концепции](#основные-концепции)
- [Создание](#создание)
- [Доступ к значению](#доступ-к-значению)
- [Методы подписки](#методы-подписки)
- [Фильтрующие подписки](#фильтрующие-подписки)
- [Вычисляемые значения](#вычисляемые-значения)
- [Асинхронные операции](#асинхронные-операции)
- [Система событий](#система-событий)
- [Методы конфигурации](#методы-конфигурации)
- [Методы жизненного цикла](#методы-жизненного-цикла)
- [Утилиты](#утилиты)
- [Свойства](#свойства)
- [QuarkEventBus (Q)](#quarkeventbus-q)

---

## Основные концепции

**Nucleus (нуклон)** — это функция-контейнер, служащая реактивным примитивом для управления потоками данных. Работает одновременно как getter и setter, автоматически уведомляет подписчиков об изменениях.

Ключевые возможности:
- Двойное назначение функции (чтение/запись)
- Паттерн Observable с богатым API подписок
- Встроенная поддержка асинхронности
- Вычисляемые значения из нескольких источников
- Расширенные возможности фильтрации и трансформации

---

## Создание

### `N(value?)`
Создаёт новый нуклон с опциональным начальным значением.

**Параметры:**
- `value?: T` - Начальное значение (опционально)

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
import { N } from '@alaq/nucleus'

const count = N(0)           // с начальным значением
const name = N<string>()     // пустой, типизированный
const data = N()             // пустой, тип выводится автоматически
```

[Подробное руководство →](#создание-подробно)

---

### `N.id(id, value?)`
Создаёт нуклон с указанным идентификатором.

**Параметры:**
- `id: string` - Уникальный идентификатор
- `value?: T` - Начальное значение (опционально)

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const userCount = N.id('user-count', 0)
console.log(userCount.id) // 'user-count'
```

---

### `N.setOnceGet(getterFn)`
Создаёт нуклон с ленивым геттером, который выполняется только один раз.

**Параметры:**
- `getterFn: () => T | Promise<T>` - Функция получения значения

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const config = N.setOnceGet(() => fetchConfig())
await config() // загружает один раз
await config() // возвращает закешированное значение
```

---

### `N.setGetter(getterFn)`
Создаёт нуклон с геттером, который выполняется при каждом чтении.

**Параметры:**
- `getterFn: () => T | Promise<T>` - Функция получения значения

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const timestamp = N.setGetter(() => Date.now())
timestamp() // всегда возвращает текущее время
```

---

### `N.setWrapper(wrapperFn)`
Создаёт нуклон с функцией-обёрткой для всех входящих значений.

**Параметры:**
- `wrapperFn: (newValue: T, prevValue: T) => T | Promise<T>` - Функция-обёртка

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const clamped = N.setWrapper((val) => Math.max(0, Math.min(100, val)))
clamped(150) // сохранит 100
clamped(-10) // сохранит 0
```

---

### `N.from(...nuclei)`
Создаёт вычисляемый нуклон из нескольких источников.

**Параметры:**
- `...nuclei: INucleus<any>[]` - Исходные нуклоны

**Возвращает:** `ComputeStrategicNucleon`

**Пример:**
```typescript
const a = N(2)
const b = N(3)
const sum = N.from(a, b).strong((x, y) => x + y)
console.log(sum.value) // 5
```

[См. Вычисляемые значения →](#вычисляемые-значения)

---

### `N.stateless()`
Создаёт нуклон без состояния (эмиттер событий без памяти).

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const click = N.stateless()
click.up(() => console.log('clicked'))
click() // вызывает слушателей, не сохраняет значение
```

---

### `N.holistic()`
Создаёт нуклон, принимающий и передающий множество аргументов.

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const multi = N.holistic()
multi.up((a, b, c) => console.log(a, b, c))
multi(1, 2, 3) // выводит: 1 2 3
```

---

## Доступ к значению

### `nucleus()`
Получить текущее значение из нуклона.

**Возвращает:** `T | Promise<T>`

**Пример:**
```typescript
const count = N(5)
console.log(count()) // 5
```

---

### `nucleus(value)`
Установить новое значение и уведомить всех подписчиков.

**Параметры:**
- `value: T` - Новое значение

**Возвращает:** `T`

**Пример:**
```typescript
const count = N(0)
count(5) // устанавливает значение 5, уведомляет подписчиков
```

---

### `nucleus.value`
Свойство только для чтения для доступа к текущему значению.

**Тип:** `T`

**Пример:**
```typescript
const count = N(10)
console.log(count.value) // 10
// count.value = 20 // Ошибка: только для чтения
```

---

### `nucleus.prev`
Доступ к предыдущему значению (доступно только внутри функций-подписчиков).

**Тип:** `T`

**Пример:**
```typescript
const count = N(0)
count.up((current) => {
  console.log(`${count.prev} → ${current}`)
})
count(5) // выводит: "0 → 5"
```

---

## Методы подписки

### `.up(receiver)`
Подписаться на изменения и получить текущее значение немедленно, если оно есть.

**Параметры:**
- `receiver: (value: T, nucleus?: INucleus<T>) => void` - Функция-получатель

**Возвращает:** `INucleus<T>` (для цепочки вызовов)

**Пример:**
```typescript
const count = N(5)
count.up(value => console.log(value)) // сразу выводит: 5
count(10) // выводит: 10
```

**Когда использовать:**
- Когда нужно текущее значение сразу при подписке
- Для синхронизации состояния UI с данными
- Для реактивных вычислений

**Особенности:**
- Если нуклон пустой (isEmpty), то callback не вызывается при подписке
- Получатель вызывается синхронно при подписке, если есть значение
- Можно передать второй параметр в callback - ссылку на сам нуклон

[Подробное руководство →](#up-подробно)

---

### `.down(receiver)`
Отписаться от изменений.

**Параметры:**
- `receiver: Function` - Та же ссылка на функцию, что была передана в `.up()`

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const handler = (v) => console.log(v)
count.up(handler)
count.down(handler) // отписались
```

**Важно:**
- Нужно использовать ту же ссылку на функцию
- Работает как для обычных подписчиков (.up), так и для "внуков" (grand listeners)

---

### `.next(receiver)`
Подписаться только на следующее изменение (не получает текущее значение).

**Параметры:**
- `receiver: (value: T) => void` - Функция-получатель

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(5)
count.next(v => console.log(v)) // не выводит сразу
count(10) // выводит: 10
```

**Когда использовать:**
- Когда текущее значение не важно
- Для ожидания следующего события
- Для отложенной реакции на изменения

---

### `.once(receiver)`
Получить значение один раз (текущее, если есть, или при следующем изменении).

**Параметры:**
- `receiver: (value: T) => void` - Функция-получатель

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(5)
count.once(v => console.log(v)) // выводит: 5, затем автоматически отписывается
count(10) // не выводит
```

**Когда использовать:**
- Для одноразовых операций
- Для инициализации компонентов
- Вместо ручной подписки/отписки

---

### `.upDown(receiver)`
Подписаться с автоматической функцией очистки во втором параметре.

**Параметры:**
- `receiver: (value: T, cleanup: () => void) => void` - Получатель с функцией очистки

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
count.upDown((value, cleanup) => {
  console.log(value)
  if (value > 100) cleanup() // автоматически отписывается при > 100
})
```

**Когда использовать:**
- Для условной отписки
- Когда нужно отписаться изнутри обработчика
- Для удобного управления жизненным циклом

---

### `.curry(context?)`
Создать каррированную функцию-сеттер (полезно для обработчиков событий).

**Параметры:**
- `context?: string` - Опциональный контекст для отладки

**Возвращает:** `(value: T) => void`

**Пример:**
```typescript
const count = N(0)
const increment = count.curry()

button.addEventListener('click', () => increment(count() + 1))
```

**Когда использовать:**
- Для передачи в обработчики событий
- Когда нужна чистая функция без контекста
- Для интеграции с библиотеками, ожидающими callback

---

### `.silent(value)`
Установить значение без уведомления подписчиков.

**Параметры:**
- `value: T` - Значение для тихой установки

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(0)
count.up(v => console.log(v)) // выводит: 0
count.silent(5) // не выводит
console.log(count.value) // 5
```

**Когда использовать:**
- Для инициализации без триггера реакций
- Для промежуточных состояний
- Для оптимизации (избежание лишних обновлений)

---

## Фильтрующие подписки

### `.upSome(receiver)`
Подписаться только на значения, которые не `null` и не `undefined`.

**Параметры:**
- `receiver: (value: T) => void` - Функция-получатель

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const user = N<User | null>(null)
user.upSome(u => console.log(u.name)) // безопасно: вызывается только когда user существует
user(null) // не вызывает
user({ name: 'Alice' }) // выводит: "Alice"
```

**Когда использовать:**
- Для работы с nullable типами
- Для безопасного доступа к свойствам
- Вместо проверок на null/undefined в каждом обработчике

---

### `.upNone(receiver)`
Подписаться только на значения `null` или `undefined`.

**Параметры:**
- `receiver: (value: T) => void` - Функция-получатель

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const user = N<User | null>({ name: 'Alice' })
user.upNone(() => console.log('Пользователь вышел'))
user(null) // выводит: "Пользователь вышел"
```

**Когда использовать:**
- Для отслеживания "пустых" состояний
- Для очистки ресурсов при отсутствии данных
- Для обработки логаутов, отмен и т.д.

---

### `.upTrue(receiver)`
Подписаться только на истинные значения (после приведения `!!value`).

**Параметры:**
- `receiver: (value: T) => void` - Функция-получатель

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const isEnabled = N(false)
isEnabled.upTrue(() => console.log('Включено'))
isEnabled(true) // выводит: "Включено"
isEnabled(false) // не вызывает
```

**Когда использовать:**
- Для булевых флагов
- Для отслеживания активации
- Для условного выполнения

---

### `.upFalse(receiver)`
Подписаться только на ложные значения.

**Параметры:**
- `receiver: (value: T) => void` - Функция-получатель

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const isLoading = N(true)
isLoading.upFalse(() => console.log('Готово'))
isLoading(false) // выводит: "Готово"
```

**Когда использовать:**
- Для отслеживания завершения процессов
- Для обработки деактивации
- Для реакции на "выключение"

---

### `.upSomeFalse(receiver)`
Подписаться на ложные значения, исключая `null` и `undefined`.

**Параметры:**
- `receiver: (value: T) => void` - Функция-получатель

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(5)
count.upSomeFalse(v => console.log('Ноль:', v))
count(0) // выводит: "Ноль: 0"
count(null) // не вызывает
count(false) // выводит: "Ноль: false"
```

**Когда использовать:**
- Когда важно различать falsy значения и отсутствие значения
- Для обработки 0, false, "" отдельно от null/undefined

---

## Вычисляемые значения

Вычисляемые значения создаются с помощью `.from()` с разными стратегиями.

### `.from(...nuclei).strong(computeFn)`
**Строгая стратегия**: Ждёт, пока все исходные нуклоны получат значения, затем вычисляет. Пересчитывает при любом изменении.

**Параметры:**
- `computeFn: (...values) => T` - Функция вычисления результата

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const price = N(100)
const qty = N(2)
const total = N.from(price, qty).strong((p, q) => p * q)

console.log(total.value) // 200
price(150)
console.log(total.value) // 300
```

**Когда использовать:**
- Когда все значения должны быть заполнены перед вычислением
- Для математических операций, требующих все операнды
- Для операций, где undefined недопустим

**Особенности:**
- Автоматически устанавливает `.finite()` режим
- Не вычисляет, пока хотя бы один источник пуст
- Пересчитывает только при реальном изменении значений

---

### `.from(...nuclei).weak(computeFn)`
**Слабая стратегия**: Пересчитывает при каждом изменении любого источника, даже если некоторые пусты. Пересчитывает только если значения реально изменились.

**Параметры:**
- `computeFn: (...values) => T` - Функция вычисления результата

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const a = N()
const b = N()
const combined = N.from(a, b).weak((x, y) => ({ x, y }))

// Вызывается даже когда a или b undefined
a(1) // вызывает вычисление
b(2) // вызывает вычисление
```

**Когда использовать:**
- Когда нужно реагировать на изменения немедленно
- Когда undefined значения приемлемы
- Для логирования или побочных эффектов

**Особенности:**
- Использует finite режим (не пересчитывает при одинаковых значениях)
- Может работать с частично заполненными данными

---

### `.from(...nuclei).some(computeFn)`
**Частичная стратегия**: Вычисляет, когда хотя бы один источник имеет значение.

**Параметры:**
- `computeFn: (...values) => T` - Функция вычисления результата

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const firstName = N('Иван')
const lastName = N()
const fullName = N.from(firstName, lastName).some((first, last) =>
  [first, last].filter(Boolean).join(' ')
)

console.log(fullName.value) // "Иван"
lastName('Петров')
console.log(fullName.value) // "Иван Петров"
```

**Когда использовать:**
- Когда частичные данные приемлемы
- Для постепенной загрузки данных
- Для опциональных полей

**Особенности:**
- Не использует finite режим (пересчитывает всегда)
- Первое вычисление происходит, когда хотя бы один нуклон заполнен

---

## Асинхронные операции

### `.setGetter(getterFn, isAsync?)`
Установить функцию для вычисления/получения значения по требованию.

**Параметры:**
- `getterFn: () => T | Promise<T>` - Функция-геттер
- `isAsync?: boolean` - Пометить как асинхронную (автоопределяется для Promise)

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const userId = N(1)
const userData = N().setGetter(async () => {
  const res = await fetch(`/api/users/${userId()}`)
  return res.json()
})

// Запуск загрузки
const user = await userData()
```

**Когда использовать:**
- Для ленивой загрузки данных
- Для вычисляемых значений, требующих асинхронных операций
- Для интеграции с внешними API

**Особенности:**
- Геттер вызывается каждый раз при чтении пустого нуклона
- Если возвращает Promise, автоматически устанавливает isAwaiting
- После получения значения, геттер больше не вызывается (пока не очистить значение)

---

### `.setOnceGet(getterFn, isAsync?)`
Установить геттер, который выполняется только один раз (ленивая инициализация).

**Параметры:**
- `getterFn: () => T | Promise<T>` - Функция-геттер
- `isAsync?: boolean` - Пометить как асинхронную

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const config = N().setOnceGet(async () => {
  console.log('Загрузка конфига...')
  return await fetchConfig()
})

await config() // выводит: "Загрузка конфига..."
await config() // использует закешированное значение, не выводит
```

**Когда использовать:**
- Для одноразовой инициализации
- Для дорогих операций, которые нужно выполнить один раз
- Для синглтон-паттернов

**Особенности:**
- После первого вызова удаляет геттер
- Кеширует результат навсегда (пока не вызвать decay)

---

### `.setWrapper(wrapperFn, isAsync?)`
Обернуть все входящие значения функцией трансформации.

**Параметры:**
- `wrapperFn: (newValue: T, prevValue: T) => T | Promise<T>` - Функция-обёртка
- `isAsync?: boolean` - Пометить как асинхронную

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const validated = N().setWrapper(async (value, prev) => {
  const isValid = await validateData(value)
  return isValid ? value : prev
})

validated({ name: 'Alice' })
validated({ name: '' }) // вернётся к предыдущему, если невалидно
```

**Когда использовать:**
- Для валидации данных
- Для нормализации входящих значений
- Для логирования всех изменений
- Для ограничения диапазона значений

**Особенности:**
- Вызывается при каждой установке значения
- Получает доступ к предыдущему значению
- Может быть асинхронной
- Если возвращает Promise, обновление откладывается до резолва

---

### `.onAwait(listener)`
Слушать изменения асинхронного состояния (загрузка/готово).

**Параметры:**
- `listener: (isAwaiting: boolean) => void` - Функция-получатель

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const data = N()
data.onAwait(isLoading => {
  console.log(isLoading ? 'Загрузка...' : 'Готово')
})

data(fetchData()) // выводит: "Загрузка..." затем "Готово"
```

**Когда использовать:**
- Для индикаторов загрузки
- Для блокировки UI во время асинхронных операций
- Для отслеживания состояния запросов

---

### `.offAwait(listener)`
Удалить слушателя асинхронного состояния.

**Параметры:**
- `listener: Function` - Та же ссылка на функцию

**Возвращает:** `void`

---

## Система событий

### `.on(event, listener)`
Добавить слушателя для пользовательских событий.

**Параметры:**
- `event: string` - Имя события
- `listener: (...args) => void` - Обработчик события

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const emitter = N()
emitter.on('custom-event', (data) => {
  console.log('Событие:', data)
})

emitter.dispatch('custom-event', { foo: 'bar' })
```

**Когда использовать:**
- Для событий жизненного цикла
- Для кастомных событий бизнес-логики
- Для интеграции с event-driven архитектурой

---

### `.off(event, listener)`
Удалить слушателя события.

**Параметры:**
- `event: string` - Имя события
- `listener: Function` - Та же ссылка на функцию

**Возвращает:** `INucleus<T>`

---

### `.dispatch(event, ...args)`
Отправить пользовательское событие.

**Параметры:**
- `event: string` - Имя события
- `...args: any[]` - Аргументы события

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
nucleus.dispatch('data-updated', newData, oldData)
```

---

### `.onClear(listener)`
Слушать события очистки.

**Параметры:**
- `listener: (level: 'value' | 'decay') => void` - Функция-получатель

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(10)
count.onClear(level => {
  console.log('Очищено:', level)
})

count.clearValue() // выводит: "Очищено: value"
count.decay()      // выводит: "Очищено: decay"
```

**Когда использовать:**
- Для очистки связанных ресурсов
- Для отмены подписок при удалении
- Для логирования жизненного цикла

---

### `.offClear(listener)`
Удалить слушателя события очистки.

**Параметры:**
- `listener: Function` - Та же ссылка на функцию

**Возвращает:** `INucleus<T>`

---

## Методы конфигурации

### `.finite(enabled?)`
Включить/выключить режим finite (передавать только когда значение реально изменилось).

**Параметры:**
- `enabled?: boolean` - Включить режим finite (по умолчанию: true)

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(0).finite()
count.up(v => console.log(v)) // выводит: 0

count(0) // не вызывает (то же значение)
count(5) // выводит: 5
count(5) // не вызывает
```

**Когда использовать:**
- Для оптимизации производительности
- Когда могут приходить дублирующиеся значения
- Для вычисляемых значений с дорогими операциями

**Особенности:**
- Использует строгое сравнение `===`
- Для объектов сравнивает ссылки, а не содержимое
- Автоматически включается в `.from().strong()`

---

### `.stateless(enabled?)`
Включить/выключить режим stateless (без хранения значения, чистый event emitter).

**Параметры:**
- `enabled?: boolean` - Включить режим stateless (по умолчанию: true)

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const click = N().stateless()
click.up(() => console.log('клик'))
click() // вызывает слушателей
console.log(click.value) // undefined (нет хранения)
```

**Когда использовать:**
- Для чистых событий (клики, нотификации)
- Для экономии памяти
- Когда история значений не важна

**Особенности:**
- `.isEmpty` всегда true
- `.value` всегда undefined
- Подписчики всё равно вызываются

---

### `.holistic(enabled?)`
Включить/выключить режим holistic (передавать множество аргументов слушателям).

**Параметры:**
- `enabled?: boolean` - Включить режим holistic (по умолчанию: true)

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const multi = N().holistic()
multi.up((a, b, c) => console.log(a, b, c))
multi(1, 2, 3) // выводит: 1 2 3
```

**Когда использовать:**
- Для событий с множественными данными
- Для передачи координат (x, y)
- Для RGB значений и т.д.

**Особенности:**
- Значения хранятся как массив
- Слушатели получают развёрнутые аргументы
- `.value` возвращает массив

---

### `.setId(id)`
Установить пользовательский идентификатор.

**Параметры:**
- `id: string` - Идентификатор

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(0).setId('user-count')
console.log(count.id) // 'user-count'
```

**Когда использовать:**
- Для отладки
- Для поиска нуклонов в системе
- Для связывания с внешними системами

---

### `.setName(name)`
Установить пользовательское имя для отладки.

**Параметры:**
- `name: string` - Имя

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(0).setName('userCounter')
console.log(count.name) // 'userCounter'
```

---

## Методы жизненного цикла

### `.decay(silent?)`
Уничтожить нуклон: очистить все подписки, слушателей и значение.

**Параметры:**
- `silent?: boolean` - Не вызывать событие clear (по умолчанию: false)

**Возвращает:** `void`

**Пример:**
```typescript
const count = N(0)
count.up(v => console.log(v))

count.decay()
// Все слушатели удалены
// Значение очищено
// Память освобождена
```

**Когда использовать:**
- При размонтировании компонентов
- При очистке ресурсов
- Для предотвращения утечек памяти

**Особенности:**
- Вызывает событие 'clear' с уровнем 'decay'
- Очищает все внутренние структуры данных
- Вызывает risen callbacks (если были установлены через from)

---

### `.clearValue()`
Очистить сохранённое значение без удаления слушателей.

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(10)
console.log(count.isEmpty) // false

count.clearValue()
console.log(count.isEmpty) // true
console.log(count.value)   // undefined
```

**Когда использовать:**
- Для сброса состояния
- Для ленивой переинициализации
- Для триггера геттера заново

---

### `.resend()`
Повторно отправить текущее значение всем подписчикам.

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(5)
count.up(v => console.log(v)) // выводит: 5
count.resend() // выводит: 5 снова
```

**Когда использовать:**
- Для принудительного обновления UI
- Для ре-валидации
- Для синхронизации состояния

---

### `.mutate(mutator)`
Мутировать текущее значение и уведомить подписчиков.

**Параметры:**
- `mutator: (value: T) => T` - Функция мутации

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const arr = N([1, 2, 3])
arr.mutate(list => {
  list.push(4)
  return list
})
// Подписчики уведомлены со значением [1, 2, 3, 4]
```

**Когда использовать:**
- Для мутации массивов и объектов
- Когда нужно изменить вложенные свойства
- Для операций типа push, splice и т.д.

**Важно:**
- Мутирует оригинальное значение (не создаёт копию)
- Должна вернуть значение
- Уведомляет подписчиков даже в finite режиме

---

## Утилиты

### `.is(value)`
Проверить, равно ли текущее значение заданному.

**Параметры:**
- `value: T` - Значение для сравнения

**Возвращает:** `boolean`

**Пример:**
```typescript
const count = N(5)
console.log(count.is(5))  // true
console.log(count.is(10)) // false
```

---

### `.cloneValue()`
Создать глубокую копию текущего значения (через JSON сериализацию).

**Возвращает:** `T`

**Пример:**
```typescript
const obj = N({ name: 'Alice', age: 30 })
const clone = obj.cloneValue()
clone.age = 31
console.log(obj.value.age) // 30 (не изменилось)
```

**Ограничения:**
- Не работает с функциями, Date, RegExp и т.д.
- Теряет прототипы классов
- Используйте для простых POJO

---

### `.injectTo(target, key?)`
Внедрить текущее значение в целевой объект.

**Параметры:**
- `target: any` - Целевой объект
- `key?: string` - Ключ свойства (по умолчанию используется id/uid нуклона)

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(5).setId('count')
const state = {}
count.injectTo(state)
console.log(state.count) // 5
```

**Когда использовать:**
- Для экспорта в обычные объекты
- Для интеграции с не-реактивным кодом
- Для снэпшотов состояния

---

### `.tuneTo(nucleus)`
Подписаться на другой нуклон и отписаться от предыдущего источника.

**Параметры:**
- `nucleus: INucleus<T>` - Исходный нуклон

**Возвращает:** `void`

**Пример:**
```typescript
const source1 = N(1)
const source2 = N(2)
const target = N()

target.tuneTo(source1)
console.log(target.value) // 1

target.tuneTo(source2) // авто-отписывается от source1
console.log(target.value) // 2
```

**Когда использовать:**
- Для переключения источников данных
- Для роутинга данных
- Для динамической подписки

---

### `.tuneOff()`
Отписаться от текущего источника tuneTo.

**Возвращает:** `void`

---

### `.addMeta(key, value?)`
Добавить метаданные к нуклону.

**Параметры:**
- `key: string` - Ключ метаданных
- `value?: any` - Значение метаданных

**Возвращает:** `INucleus<T>`

**Пример:**
```typescript
const count = N(0)
count.addMeta('category', 'analytics')
count.addMeta('priority', 'high')
```

**Когда использовать:**
- Для хранения дополнительной информации
- Для категоризации
- Для debugging информации

---

### `.getMeta(key)`
Получить метаданные по ключу.

**Параметры:**
- `key: string` - Ключ метаданных

**Возвращает:** `any`

**Пример:**
```typescript
const category = count.getMeta('category')
console.log(category) // 'analytics'
```

---

### `.hasMeta(key)`
Проверить наличие метаданных.

**Параметры:**
- `key: string` - Ключ метаданных

**Возвращает:** `boolean`

---

### `.deleteMeta(key)`
Удалить метаданные по ключу.

**Параметры:**
- `key: string` - Ключ метаданных

**Возвращает:** `boolean`

---

## Свойства

### `.value`
Текущее значение (только для чтения).

**Тип:** `T`

---

### `.prev`
Предыдущее значение (доступно только внутри callback'ов подписчиков).

**Тип:** `T`

---

### `.isEmpty`
Есть ли в нуклоне значение.

**Тип:** `boolean`

**Пример:**
```typescript
const n = N()
console.log(n.isEmpty) // true
n(5)
console.log(n.isEmpty) // false
```

---

### `.isFilled`
Есть ли в нуклоне значение (противоположность isEmpty).

**Тип:** `boolean`

---

### `.haveListeners`
Есть ли у нуклона подписчики.

**Тип:** `boolean`

**Пример:**
```typescript
const n = N(0)
console.log(n.haveListeners) // false
n.up(() => {})
console.log(n.haveListeners) // true
```

---

### `.uid`
Уникальный идентификатор (генерируется автоматически).

**Тип:** `string`

---

### `.id`
Пользовательский идентификатор (устанавливается через `.setId()` или `N.id()`).

**Тип:** `string`

---

### `.name`
Пользовательское имя (устанавливается через `.setName()`).

**Тип:** `string`

---

### `.isAsync`
Использует ли нуклон асинхронные операции.

**Тип:** `boolean`

---

### `.isAwaiting`
Ожидает ли нуклон завершения асинхронной операции.

**Тип:** `boolean | Promise<T>`

---

### `.isStateless`
Находится ли нуклон в режиме stateless.

**Тип:** `boolean`

---

### `.isHoly`
Находится ли нуклон в режиме holistic (множественные аргументы).

**Тип:** `boolean`

---

### `.parents`
Массив родительских нуклонов (если создан через `.from()`).

**Тип:** `INucleus<any>[]`

---

## QuarkEventBus (Q)

Шина событий для межнуклонной коммуникации.

### `QuarkEventBus(id?)`
Создать новую шину событий.

**Параметры:**
- `id?: string` - Опциональный идентификатор

**Возвращает:** `IQuarkBus`

**Пример:**
```typescript
import { QuarkEventBus  } from '@alaq/nucleus'

const bus = QuarkEventBus('app-bus')
```

---

### `.addEventListener(event, listener)`
Добавить слушателя события на шину.

**Параметры:**
- `event: string` - Имя события
- `listener: (data: any) => void` - Обработчик события

**Пример:**
```typescript
bus.addEventListener('user-login', (user) => {
  console.log('Пользователь вошёл:', user)
})
```

---

### `.removeEventListener(event, listener)`
Удалить слушателя события.

**Параметры:**
- `event: string` - Имя события
- `listener: Function` - Та же ссылка на функцию

---

### `.dispatchEvent(event, data)`
Отправить событие.

**Параметры:**
- `event: string` - Имя события
- `data: any` - Данные события

**Пример:**
```typescript
bus.dispatchEvent('user-login', { id: 1, name: 'Alice' })
```

---

### `.addEverythingListener(listener)`
Слушать все события на шине.

**Параметры:**
- `listener: (event: string, data: any) => void` - Универсальный обработчик

**Пример:**
```typescript
bus.addEverythingListener((event, data) => {
  console.log(`Событие: ${event}`, data)
})
```

---

### `.addBus(targetBus)`
Подключить эту шину к другой (перенаправлять все события).

**Параметры:**
- `targetBus: IQuarkBus` - Целевая шина

**Пример:**
```typescript
const mainBus = QuarkEventBus('main')
const subBus = QuarkEventBus('sub')

subBus.addBus(mainBus)
// Теперь все события из subBus перенаправляются в mainBus
```

---

### `.removeBus(targetBus)`
Отключиться от шины.

**Параметры:**
- `targetBus: IQuarkBus` - Целевая шина

---

### `.removeListener(listener)`
Удалить слушателя из всех событий.

**Параметры:**
- `listener: Function` - Функция слушателя

---

### `.decay()`
Очистить все слушатели и связи шины.

---


## Миграция и совместимость

Все методы поддерживают цепочку вызовов где это уместно. API стабилен и обратно совместим в рамках версии 5.x.

Для пользователей TypeScript, полные определения типов доступны в `types/INucleus.d.ts`.

---

## Советы по производительности

1. **Используйте `.finite()`** для значений, которые могут получать дубликаты
2. **Используйте `.stateless()`** для чистых потоков событий для экономии памяти
3. **Предпочитайте `.once()`** вместо ручной подписки/отписки
4. **Вызывайте `.decay()`** на неиспользуемых нуклонах для предотвращения утечек памяти
5. **Используйте `.from().strong()`** с finite режимом для оптимальных вычисляемых обновлений
6. **Избегайте тяжёлых вычислений** в подписчиках - выносите в отдельные computed нуклоны
7. **Используйте `.silent()`** для пакетных обновлений без триггера реакций

---

## Расширение функциональности

### Установка расширений нуклона

```typescript
import { installNucleonExtensions } from '@alaq/nucleus'

installNucleonExtensions({
  // Пользовательский метод
  log(label?: string) {
    this.up(v => console.log(`[${label || this.id}]`, v))
    return this._
  },

  // Дебаунс
  debounce(ms: number) {
    let timer
    return this.setWrapper((v) => {
      clearTimeout(timer)
      return new Promise(resolve => {
        timer = setTimeout(() => resolve(v), ms)
      })
    })
  }
})

// Теперь доступны на всех нуклонах
const count = N(0)
count.log('counter') // выводит изменения с меткой
```

---

## Лицензия

TVR
