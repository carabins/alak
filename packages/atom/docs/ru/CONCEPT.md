# Концепция Atom: Оркестратор Состояния

Этот документ объясняет философию `@alaq/atom` — самого мощного инструмента в экосистеме Alaq.

## 1. Зачем нужен Atom?
Если **Quark** и **Nucl** — это кирпичики, то **Atom** — это чертеж и строительная бригада. 

В сложных приложениях неудобно управлять сотнями разрозненных переменных. Нам нужна структура, типизация и автоматизация. Atom позволяет использовать привычные классы TypeScript для описания сложных моделей состояния, при этом сохраняя экстремальную производительность экосистемы Alaq.

## 2. Класс как Схема
В Atom вы описываете данные в виде обычного класса. Это дает вам:
- **Типизацию из коробки**: IDE понимает структуру вашего стора.
- **Инкапсуляцию**: Логика (методы) и данные (свойства) живут в одном месте.
- **Чистоту кода**: Вы не пишете `const a = Nu()`, `const b = Nu()`. Вы просто объявляете поля класса.

```typescript
class TodoStore {
  items = []; // Автоматически станет Nucl
  filter = 'all';

  add(text) {
    this.items = [...this.items, { text, done: false }];
  }
}
const todo = Atom(TodoStore);
```

## 3. Магия "Прозрачной" Реактивности
Atom использует современные возможности JavaScript (Proxy), чтобы сделать реактивность невидимой.
Когда вы пишете `this.items = ...` внутри метода класса, Atom перехватывает это действие и обновляет соответствующий нуклон. Вам не нужно вызывать функции вручную или использовать специальные сеттеры.

При этом вы всегда можете "заглянуть под капот": любое поле `name` имеет своего "близнеца" `$name`, который является полноценным объектом Nucl.

## 4. Автоматические вычисления (Computed)
Одна из самых мощных функций Atom — интеллектуальные геттеры. Благодаря системе отслеживания зависимостей (Dependency Tracking), любой геттер в классе автоматически становится реактивным.

**Как это работает:**
1. Когда геттер вызывается в первый раз, Atom "слушает", какие свойства модели были прочитаны.
2. Он создает `fusion` между этими свойствами и результатом геттера.
3. Теперь геттер будет пересчитываться только тогда, когда изменятся его реальные зависимости.

## 5. Плагины и Конвенции
Atom спроектирован быть расширяемым. Через систему плагинов можно внедрять любые архитектурные паттерны:
- Автоматическая синхронизация с LocalStorage.
- Логирование действий.
- Интеграция с внешними шинами данных.

По умолчанию Atom следует принципу "соглашение важнее конфигурации", обеспечивая разумное поведение для большинства сценариев.

## Резюме
- **Классы** — это удобный способ описания структуры.
- **Proxy** — делает реактивность бесшовной.
- **$ префикс** — дает доступ к низкоуровневым инструментам.
- **Computed** — избавляет от ручного управления зависимостями.
